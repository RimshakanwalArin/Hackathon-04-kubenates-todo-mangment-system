<!--
SYNC IMPACT REPORT
==================
Version Change: 1.0.0 → 1.1.0 (MINOR: Frontend phase added)
Modified Principles: 8 total (added VII. Chat-First UX, VIII. API-Driven Frontend)
Added Sections: Frontend tech stack, Frontend NFRs, Phase II Definition of Done
Removed Sections: None
Templates Updated:
  - spec-template.md: ✅ Aligned with SDD principles (reusable for Phase II)
  - plan-template.md: ✅ Constitution Check gate compatible
  - tasks-template.md: ✅ Task categorization supports TDD + observability
  - phr-template.prompt.md: ✅ Compatible with PHR recording requirements
Follow-up: None deferred
Change Rationale: Phase II frontend development requires chat-first UX and API-driven communication principles
==================
-->

# Cloud Native Todo Chatbot Constitution

## Core Principles

### I. Cloud-Native First

Backend MUST be stateless, container-friendly, and horizontally scalable.
- No persistent local state; all data externalized to DB or cache
- Ready for Docker containerization and Kubernetes deployment
- Restarts must be safe (no loss of in-flight requests; circuit breakers on dependencies)
- RATIONALE: Enables zero-downtime deployments, fault isolation, auto-scaling

### II. API First

All features MUST be exposed via clear REST contracts with predictable JSON responses.
- Every endpoint has documented request/response schema
- Chatbot intent MUST map cleanly to backend actions
- Versioning strategy: URL-based (`/api/v1`, `/api/v2`) for breaking changes
- Error responses: standardized `{"error": "message", "code": "CODE"}` format
- RATIONALE: Clear contracts enable independent frontend/backend teams and chatbot integration

### III. Spec-Driven Development

Architecture and code MUST be generated from written specifications.
- Write Spec (WHAT) → Generate Plan (HOW) → Break Into Tasks → Implement & Verify
- Spec MUST define acceptance criteria, API contracts, and success metrics before design
- Plan MUST justify all architectural decisions; identify tradeoffs explicitly
- RATIONALE: Reduces rework, ensures alignment, makes decisions auditable

### IV. AI-Generated Code

All implementation code MUST be generated by Claude Code or AI agents; NO manual coding.
- Every function, test, config generated via spec-driven workflow
- Manual edits allowed only for bug fixes in generated code (must be documented)
- Code review focuses on contract compliance, not style (AI output consistent)
- RATIONALE: Reproducible, auditable, eliminates human coding errors at scale

### V. Test-First Mandatory

Testing MUST precede implementation (Red-Green-Refactor cycle non-negotiable).
- Test case MUST be written and approved by user before code generation
- Tests MUST verify contract (input → output) independently
- Integration tests MUST cover inter-service communication and shared contracts
- Coverage MUST be ≥80% for all generated code
- RATIONALE: Prevents bugs, clarifies requirements, enables confident refactoring

### VI. Security by Default

No hardcoded secrets, minimal attack surface, environment-based config.
- All secrets MUST come from environment variables or secure config files (never committed)
- API endpoints MUST validate input (XSS, SQL injection, command injection prevention)
- Errors MUST NOT leak internal state (e.g., stack traces, DB schema)
- Logging MUST NOT capture credentials, PII, or secrets
- RATIONALE: Reduces breach risk, meets compliance requirements, ensures auditable security

### VII. Chat-First User Experience (Phase II - Frontend)

Frontend MUST prioritize conversational interaction, not traditional CRUD forms.
- UI MUST present messages in chat format (user → bot conversation)
- Message history MUST be retained during session (ephemeral storage OK)
- Bot responses MUST be clear and actionable (user feedback, confirmation, errors)
- No complex modals or multi-step workflows; single message input suffices
- RATIONALE: Intuitive UX aligned with chatbot paradigm; reduces cognitive load

### VIII. API-Driven Frontend Communication (Phase II - Frontend)

Frontend MUST exclusively communicate via backend REST API; no hardcoded logic.
- All chat intents MUST route through `/api/v1/chat` or corresponding `/api/v1/todos/*` endpoints
- Frontend MUST NOT implement business logic; backend owns all validation and state
- Error handling MUST gracefully present backend error codes to user
- Backend availability check: health endpoint query before main app load
- RATIONALE: Single source of truth; enables backend-driven feature toggles and rules

## Technology Stack

### Backend (Phase I - Complete)

| Layer          | Technology                                    | Rationale                                    |
|---|---|---|
| **Runtime**    | Node.js (v18+)                                | Rapid API development, container-native     |
| **API Style**  | RESTful JSON                                  | Universal client support, chatbot-friendly  |
| **Data Store** | In-memory (Phase I) / Neon PostgreSQL (Phase II) | Dev-friendly; upgradeable without API changes |
| **Container**  | Docker (Alpine-based)                         | Kubernetes-compatible, minimal image size   |
| **Logging**    | Winston (JSON) + stdout                       | Container-native, searchable, audit trail   |
| **Testing**    | Jest + Supertest                              | Contract-driven, integration-ready          |

### Frontend (Phase II - New)

| Layer          | Technology                                    | Rationale                                    |
|---|---|---|
| **Framework**  | React or Next.js (AI-selected)                | Component-driven, SSR-capable, state management |
| **Styling**    | Tailwind CSS / CSS-in-JS                      | Utility-first, responsive chat UI            |
| **API Client** | Fetch API / Axios                             | Direct HTTP integration with backend        |
| **State**      | React Context or Zustand (AI-selected)        | Client-side ephemeral, conversation state   |
| **Build**      | Vite or Next.js build                         | Fast development, optimized production      |
| **Container**  | Docker (Nginx + static assets)                | Kubernetes-ready frontend service           |
| **Testing**    | Jest + React Testing Library                  | Component + integration testing              |

## Code Quality Standards

### Smallest Viable Change

- No unrelated refactoring or feature creep
- Bug fix ≠ surrounding code cleanup
- Simple feature ≠ extra configurability
- Build for current requirements, not hypothetical futures

### Clear Code References

- Always cite modified files with line numbers: `src/api.js:42`
- Proposed changes use fenced code blocks with context

### Explicit Constraints

- List invariants upfront (e.g., "IDs immutable after creation")
- Document error paths: what fails, why, and recovery action
- State non-goals clearly (e.g., "Not implementing pagination in Phase I")

### No Over-Engineering

- Trust framework guarantees and internal code
- Validate only at system boundaries (user input, external APIs)
- One-time operations MUST NOT get helper functions or abstractions
- Delete unused code completely (no placeholder comments)

## Development Workflow

### Phase 0: Specification (User → AI)

1. User provides feature description, API contracts, acceptance criteria
2. AI generates `spec.md` with prioritized user stories, functional requirements, success metrics
3. User reviews and approves spec before proceeding

### Phase 1: Planning (AI Research → Design)

1. AI generates `plan.md` with technical context, architecture decisions, project structure
2. Plan MUST include Constitution Check gate: verify all principles are satisfied
3. User approves plan and any architectural decisions before code generation

### Phase 2: Task Generation (AI → Breakdown)

1. AI generates `tasks.md` with granular, testable work items
2. Each task MUST be independently completable and verifiable
3. Tasks reference spec acceptance criteria and plan architecture

### Phase 3: Implementation & Verification (AI Code Generation)

1. AI generates code for each task using established patterns
2. Inline acceptance checks: comments showing what test verifies what requirement
3. Code MUST pass all tests before marking task complete

### Phase 4: Integration & Deployment

1. All tasks complete; code merged to main branch
2. Docker image built and tested locally
3. Kubernetes manifests generated (health check, resource limits)
4. PHR (Prompt History Record) created for entire session

## API Contracts (Phase 0 Deliverable)

All endpoints return standardized structure. Errors return `{"error": "message", "code": "ERROR_CODE"}`.

### Todo Operations

| Method | Endpoint        | Purpose            | Status Code |
|---|---|---|---|
| POST   | `/api/v1/todos`      | Create a todo      | 201 Created |
| GET    | `/api/v1/todos`      | List all todos     | 200 OK      |
| PUT    | `/api/v1/todos/{id}` | Update todo status | 200 OK      |
| DELETE | `/api/v1/todos/{id}` | Delete a todo      | 204 No Content |

### Chatbot Integration (Optional but Recommended)

| Method | Endpoint        | Purpose                  |
|---|---|---|
| POST   | `/api/v1/chat`       | Intent → action mapping  |

### Health & Observability

| Method | Endpoint     | Purpose                              |
|---|---|---|
| GET    | `/health`    | Kubernetes liveness probe            |
| GET    | `/ready`     | Kubernetes readiness probe           |

## Non-Functional Requirements

### Backend Performance (Phase I)

- **p95 Latency**: <200ms locally for all endpoints
- **Throughput**: ≥100 req/s single instance
- **Database**: Response time <50ms for simple queries

### Frontend Performance (Phase II)

- **Page Load**: <2s first meaningful paint (local development)
- **Chat Response**: <1s end-to-end (user input → bot response display)
- **Bundle Size**: <200KB gzipped (initial load)
- **Interaction Latency**: <100ms for UI feedback (message input, sending)

### Scalability

- Backend: Stateless design via load balancer; no session affinity
- Frontend: Static build deployable to CDN; no server-side dependencies
- Database: Connection pooling ≤10 concurrent per backend instance

### Reliability

- Backend: No persistent local state (crash-safe restarts)
- Frontend: Message history recovered from session (localStorage or memory)
- Dependency timeouts: 5s socket, 10s total request
- Circuit breaker on DB: fail-fast after 3 consecutive failures
- Graceful degradation: offline mode shows error, retains user input

### Observability

- Backend: All errors logged with request ID for tracing
- Frontend: Console errors/warnings for development; no personally identifiable logs
- Metrics: request count, latency, error rate per endpoint/component
- Health check: backend responds within 100ms; no dependencies

### Security

- All secrets from environment variables (not committed)
- Backend: Input validation on all user-provided data
- Frontend: XSS prevention via React's auto-escaping; no innerHTML
- Error messages: no stack traces, no DB schema leakage
- Logging: no credentials, PII, or secrets captured

## Definition of Done

### For Features (Backend Phase I)

- ✅ Spec written with acceptance criteria and API contracts
- ✅ Plan approved with architecture decisions documented
- ✅ Tasks generated and independently testable
- ✅ All tests passing (unit + integration + contract): ≥80% coverage
- ✅ Code generated via AI agents (no manual coding)
- ✅ Health endpoints operational (/health, /ready)
- ✅ Docker-ready (Dockerfile and .dockerignore provided)
- ✅ Kubernetes-compatible (stateless, health checks, env-based config)
- ✅ PHR created for entire session

### For Features (Frontend Phase II)

- ✅ Spec written with UI/UX acceptance criteria, API integration contract
- ✅ Plan approved with component architecture, state management design
- ✅ Tasks generated for components, integration points, error handling
- ✅ All tests passing (unit + integration): ≥80% coverage
- ✅ Code generated via AI agents (no manual coding)
- ✅ Chat UI functional with message history
- ✅ Backend API integration verified (happy path + error cases)
- ✅ Static build optimized (<200KB gzipped)
- ✅ Docker-ready (Nginx-based static serving)
- ✅ Kubernetes-compatible (health checks, env-based API endpoint config)
- ✅ PHR created for entire session

### For Code Changes

- ✅ Constitution Check gate passed
- ✅ All code generated via AI (spec-driven)
- ✅ Tests written first, then code (TDD cycle)
- ✅ No hardcoded secrets; all config environment-based
- ✅ Error messages non-leaking, logged with request ID
- ✅ Acceptance criteria in code comments (what test verifies what requirement)

## Governance

### Amendment Process

- Amendments MUST be documented with rationale in this file
- Major changes (principle removal/redefinition) require user consent
- Minor changes (clarifications) can be batched and ratified quarterly
- Version bumping follows semantic versioning:
  - **MAJOR**: Backward-incompatible principle changes or removals
  - **MINOR**: New principle/section or materially expanded guidance
  - **PATCH**: Clarifications, wording, non-semantic refinements

### Compliance Verification

- All PRs MUST verify Constitution Check gate before merge
- Spec MUST list which principles it satisfies
- Plan MUST document any justified exceptions to principles
- Code review MUST confirm AI-generation and TDD compliance

### Guidance Runtime

Development guidance and command workflows are documented in:
- `.specify/templates/commands/`: Command execution workflows
- `.specify/scripts/bash/`: Helper scripts for reproducible operations
- Individual feature docs: `specs/<feature>/quickstart.md` for context

**Constitution supersedes all other practices. In conflicts, constitution prevails.**

---

**Version**: 1.1.0 | **Ratified**: 2025-12-23 | **Last Amended**: 2025-12-23
